/*
 * Initial main.c file generated by Glade. Edit as required.
 * Glade will not overwrite this file.
 */

/*
  petite remarque sur la gestion de la memoire dans wmccc: on utilise un
  garbage-collector très puissant. Pour le mettre en action, il suffit
  d'appeler exit(0). Side-effect: met fin au programme.
*/

#ifdef HAVE_CONFIG_H
#  include <config.h>
#endif

#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>
#define GLOBALS_HERE
#define WMCCC_C
#include "wmccc.h"
#include "wmccc_interface.h"
#include "wmccc_support.h"

int run_edit_dialog();

GdkColor*
irgb_to_gdkcolor(unsigned icol) {
  static GdkColor color;
  color.red   = ((icol & 0xff0000) >> 16) * 256+ 127;
  color.green = ((icol & 0x00ff00) >> 8) * 256 + 127;
  color.blue  = ((icol & 0x0000ff)     ) * 256 + 127;
    
  gdk_colormap_alloc_color( gdk_colormap_get_system(), &color, FALSE, TRUE);
  return &color;
}

unsigned gdkcolor_to_irgb(GdkColor *c) {
  g_assert(c);
  return ((c->red/256) << 16) + ((c->green/256) << 8) + (c->blue/256);
}

GtkWidget *messagebox_dialog(char *widget) {
  static GtkWidget *d = NULL;
  if (!d) { d = create_messagebox_dialog(); g_assert(d); }
  if (widget == NULL) 
    return d;
  else {
    GtkWidget *w = lookup_widget(d, widget); g_assert(w); 
    return w;
  }
}

GtkWidget *new_board_dialog(char *widget) {
  static GtkWidget *d = NULL;
  if (!d) { d = create_new_board_dialog(); g_assert(d); }
  if (widget == NULL) 
    return d;
  else {
    GtkWidget *w = lookup_widget(d, widget); g_assert(w);    
    return w;
  }
}
GtkWidget *pinnipede_dialog(char *widget) {
  static GtkWidget *d = NULL;
  if (!d) { d = create_pinnipede_dialog(); g_assert(d); }
  if (widget == NULL) 
    return d;
  else {
    GtkWidget *w = lookup_widget(d, widget); g_assert(w);
    return w;
  }
}

GtkWidget *edit_dialog(char *widget) {
  static GtkWidget *d = NULL;
  if (!d) { d = create_edit_dialog(); g_assert(d); }
  if (widget == NULL) 
    return d;
  else {
    GtkWidget *w = lookup_widget(d, widget); g_assert(w);
    return w;
  }
}

GtkWidget *bronson_wizard(char *widget) {
  static GtkWidget *d = NULL;
  if (!d) { d = create_bronson_wizard(); g_assert(d); }
  if (widget == NULL) 
    return d;
  else {
    GtkWidget *w = lookup_widget(d, widget); g_assert(w);
    return w;
  }
}

GtkWidget *sitelist_dialog(char *widget) {
  static GtkWidget *d = NULL;
  if (!d) { d = create_sitelist_dialog(); g_assert(d); }
  if (widget == NULL) 
    return d;
  else {
    GtkWidget *w = lookup_widget(d, widget); g_assert(w);
    return w;
  }
}

/* lit out relit les prefs */
int read_prefs() {
  char *err;
  if (Prefs && glob.nb_selected_sites) { 
    quick_message("you should not be able to do that!"); exit(1); 
  }
  if (Prefs) wmcc_prefs_destroy(Prefs);
  Prefs = g_new0(GeneralPrefs, 1);
  wmcc_prefs_set_default(Prefs);

  err = wmcc_prefs_read_options(Prefs, glob.options_file,1);
  if (err || Prefs->nb_sites == 0) {
    if (!err && Prefs->nb_sites == 0) err = "no site..";
    quick_message("error reading %s: %s", glob.options_file, err); return 2;
  }
  return 0;
}

int new_options_from_string(const char *s) {
  FILE *f;
  char *err;
  int old_nb_site = Prefs->nb_sites, i;
  char *congratulations = NULL;
  if (!s || strlen(s) == 0) return -1;
  f = open_wfile(glob.tmp_options_file);
  if (!f) {
    quick_message("could not create temporary file '%s' : %s", glob.tmp_options_file, strerror(errno));
    return -1;
  }
  if (fputs(s,f) == EOF) {
    quick_message("could not create temporary file '%s' : %s", glob.tmp_options_file, strerror(errno));
    return -1;
  }
  fclose(f);
  err = wmcc_prefs_read_options(Prefs, glob.tmp_options_file, 1);
  if (err) {
    g_print("error while parsing preferences: %s\n", err);
    if (read_prefs() != 0) { // on remet celles d'avant
      fprintf(stderr, "ça commence a bien faire.\n"); exit(1); 
    }    
    return 2;
  }
  for (i = old_nb_site; i < Prefs->nb_sites; ++i) {
    congratulations = str_cat_printf(congratulations, "%s%s", Prefs->site[i]->site_name, (i?"":", "));
  }
  quick_message("Congratulations !\nThe options were successfully parsed\n%d sites were added: %s",
                Prefs->nb_sites-old_nb_site,congratulations);
  free(congratulations);
  return 0;
}

/* Function to open a dialog box displaying the message provided. */
void quick_message(gchar *message_fmt, ...) {
  va_list ap;
  GtkWidget *label;
  char s[1024];
  va_start(ap, message_fmt);
  vsnprintf(s,1024,message_fmt,ap);
  va_end(ap);
  label = messagebox_dialog("messagebox_label"); 
  gtk_label_set_text(GTK_LABEL(messagebox_dialog("messagebox_label")), s);
  gtk_dialog_run (GTK_DIALOG(messagebox_dialog(NULL)));
}

GtkWidget *colorselection_dialog() {
  static GtkWidget *d = NULL;
  if (!d) { d = gtk_color_selection_dialog_new("select a color"); g_assert(d); }
  return d;
}

int change_or_create_site_prefs(int sid, SitePrefs *sp0) {
  if (sid == -1 || sid > Prefs->nb_sites-1) {
    sid = Prefs->nb_sites++;
    if (Prefs->nb_sites == MAX_SITES) {
      quick_message("too much sites!");
      return -1;
    }  
    Prefs->site[sid] = g_new(SitePrefs,1);
    wmcc_site_prefs_set_default(Prefs->site[sid]);
  }
  wmcc_site_prefs_copy(Prefs->site[sid], sp0);
  return 0;
}

/* ------ widget management ------*/

typedef struct TouchedInfo_ {
  int touched;
  int multivalued;
  GtkWidget *feedback_label;
} TouchedInfo;

void
widget_value_changed_callback(GtkWidget *w, TouchedInfo *ti) {
  g_assert(ti);
  if (ti->touched == -1) return;
  printf("ptouiched=%d\n", ti->touched);
  (ti->touched)++;
  if (ti->feedback_label) {
    gtk_widget_modify_fg(ti->feedback_label, GTK_STATE_NORMAL, &glob.modif_widget_color);
    gtk_widget_modify_text(w, GTK_STATE_NORMAL, &glob.modif_widget_color);
    gtk_label_set_text(GTK_LABEL(ti->feedback_label), "[modified]");
  }
  /*gtk_widget_modify_bg(w, GTK_STATE_NORMAL, &glob.modif_widget_color);
  gtk_widget_modify_bg(w, GTK_STATE_SELECTED, &glob.modif_widget_color);
  gtk_button_set_label(GTK_BUTTON(w), "plop!");*/
}

/* ---------------- toggle buttons ----------------*/
void multi_set_toggle_button(GtkWidget *w, GtkWidget *feedback_label, int value, int count) {
  TouchedInfo *ti = NULL;
  printf("multi set toggle : count = %d, val = %d\n",count,value);
  if (count == 0) {
    ti = g_new0(TouchedInfo,1); 
    ti->feedback_label = feedback_label; ti->multivalued = 0;
    g_object_set_data(G_OBJECT(w), "touched", ti);
    g_signal_connect ((gpointer) w, "toggled",
                      G_CALLBACK (widget_value_changed_callback),
                      g_object_get_data(G_OBJECT(w), "touched"));
    ti->touched = -1;
    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(w), value);
  } else {
    ti = g_object_get_data(G_OBJECT(w), "touched");
    if (value != gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(w)) && !ti->multivalued) 
      ti->multivalued = 1;
    /*    if (!gtk_toggle_button_get_inconsistent(GTK_TOGGLE_BUTTON(w)) &&
        gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(w)) != value) {
      gtk_toggle_button_set_inconsistent(GTK_TOGGLE_BUTTON(w), TRUE);
    }
    */
  }
  if (ti->feedback_label) {
    if (ti->multivalued) {
      gtk_widget_modify_fg(ti->feedback_label, GTK_STATE_NORMAL, &glob.modif_widget_color);
    } else gtk_widget_set_style (ti->feedback_label, NULL);
    gtk_label_set_text(GTK_LABEL(ti->feedback_label), ti->multivalued ? "[different values!]" : "[unchanged]");
  }
  ti->touched = 0;
}

int multi_get_toggle_button(GtkWidget *w, gboolean *value) {
  TouchedInfo *ti = g_object_get_data(G_OBJECT(w), "touched"); g_assert(ti);
  if (ti->touched) {
    *value = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(w));
  }
  return ti->touched;
}

/* ------------------- color button -------------------------- */

void color_button_update_color(GtkWidget *w, GdkColor *c, int value_store) {
  if (value_store) g_object_set_data(G_OBJECT(w), "value", GINT_TO_POINTER(gdkcolor_to_irgb(c)));
  gtk_widget_modify_bg(w, GTK_STATE_PRELIGHT, c);
  gtk_widget_modify_bg(w, GTK_STATE_NORMAL, c);
}

void color_button_clicked_callback(GtkWidget *w, TouchedInfo *ti) {
  GdkColor c;
  
  GtkWidget *colorsel = GTK_COLOR_SELECTION_DIALOG(colorselection_dialog())->colorsel;
  
  gtk_color_selection_set_current_color(GTK_COLOR_SELECTION(colorsel), 
                                        irgb_to_gdkcolor(GPOINTER_TO_INT(g_object_get_data(G_OBJECT(w), "value"))));
  gtk_color_selection_set_has_palette(GTK_COLOR_SELECTION(colorsel), TRUE);
  int rep = gtk_dialog_run(GTK_DIALOG(colorselection_dialog()));

  gtk_color_selection_get_current_color(GTK_COLOR_SELECTION(colorsel), &c);
  gtk_widget_hide(GTK_WIDGET(colorselection_dialog()));
  
  if (rep == GTK_RESPONSE_OK) {
    printf("colorselection_dialog returned %d %d/%d/%d\n", rep, c.red, c.green, c.blue);
    color_button_update_color(w,&c,1);
    widget_value_changed_callback(w,ti);
  }
}

void multi_set_color_button(GtkWidget *w, unsigned value, int count) {
  TouchedInfo *ti = NULL;
  printf("multi set color button : count = %d, val = %d\n",count,value);
  if (count == 0) {
    ti = g_new0(TouchedInfo,1); 
    ti->feedback_label = GTK_BIN(w)->child; ti->multivalued = 0;
    g_object_set_data(G_OBJECT(w), "touched", ti);
    g_signal_connect ((gpointer) w, "clicked",
                      G_CALLBACK (color_button_clicked_callback),
                      g_object_get_data(G_OBJECT(w), "touched"));
    ti->touched = -1;
    printf("bgcolor : %06x\n", value);
    //gtk_widget_modify_text(ti->feedback_label, GTK_STATE_NORMAL, irgb_to_gdkcolor(value));
    color_button_update_color(w, irgb_to_gdkcolor(value), 1);
  } else {
    ti = g_object_get_data(G_OBJECT(w), "touched");
    if (value != (unsigned)GPOINTER_TO_INT(g_object_get_data(G_OBJECT(w), "value")) && !ti->multivalued) {
      gtk_widget_set_style (ti->feedback_label, NULL);
      ti->multivalued = 1;
    }
  }
  if (ti->multivalued) {
    //gtk_widget_set_style(w, NULL); // marche pô 
    color_button_update_color(w, irgb_to_gdkcolor(0x808080), 0);
  }
  gtk_label_set_text(GTK_LABEL(ti->feedback_label), ti->multivalued ? "[*val!]" : "[unchanged]");
  ti->touched = 0;
}

int multi_get_color_button(GtkWidget *w, unsigned *value) {
  TouchedInfo *ti = g_object_get_data(G_OBJECT(w), "touched"); g_assert(ti);
  if (ti->touched) {
    *value =  GPOINTER_TO_INT(g_object_get_data(G_OBJECT(w), "value"));
    printf("multi_get_color_button got %06x\n", *value);
  }
  return ti->touched;
}


int validate_cookies(const char *cookies, SitePrefs *sp) { 
  ASSIGN_STRING_VAL(sp->user_cookie, cookies); return 0; 
}
int validate_board_post(const char *s, SitePrefs *sp) { ASSIGN_STRING_VAL(sp->board_post, s); return 0; }
int validate_path_board_add(const char *s, SitePrefs *sp) { ASSIGN_STRING_VAL(sp->path_board_add, s); return 0; }
int validate_backend_path(const char *s_, SitePrefs *sp) {
  int err = 0;
  char *s = strdup(s_), *p;
  if (str_is_empty(s)) { quick_message("Empty backend path"); return -1; }
  url_au_coiffeur(s,0);
  p = strrchr(s,'/');
  FREE_STRING(sp->site_root); FREE_STRING(sp->site_path); FREE_STRING(sp->path_board_backend);
  if (p) {
    *p = 0;
    option_site_root(s, sp, 0);
    if (sp->site_root) {
      ASSIGN_STRING_VAL(sp->path_board_backend, p);
    }
  } 
  err = (sp->site_root == NULL);
  free(s);
  if (err) {
    quick_message("malformed backend url");
    return -1;
  } else return 0;
}
int validate_site_name(const char *s, SitePrefs *sp, int check_new_site) {
  if (str_is_empty(s)) { quick_message("Empty site name"); return -1; }
  if (check_new_site) {
    char *s2 = strdup(s); str_trim(s2);
    int i;
    for (i=0; i < Prefs->nb_sites; ++i) {
      int j;
      assert(Prefs->site[i]);
      for (j=0; j < Prefs->site[i]->nb_names; ++j)
        if (strcasecmp(Prefs->site[i]->all_names[j], s) == 0) {
          printf("oups\n");
          quick_message("there is already a site called %s", s); return -1;
        }
    }
    free(s2);
  }
  if (sp->all_names == NULL) { sp->all_names = g_new0(char*,4); }
  ASSIGN_STRING_VAL(sp->all_names[0], s);
  return 0;
}

void
switch_to_edit_dialog_callback(GtkButton *button, gpointer user_data) {
  int rep;
  GtkWidget *win = gtk_widget_get_toplevel(GTK_WIDGET(button)); g_assert(win);
  //gtk_widget_hide(win);
  rep = run_edit_dialog();
  printf("rep = %d\n",rep);
  if (rep == GTK_RESPONSE_OK) { 
    printf("resp ok\n");
    gtk_dialog_response(GTK_DIALOG(new_board_dialog(NULL)),GTK_RESPONSE_ACCEPT); 
  } //else gtk_widget_show(win);
  gtk_widget_hide(edit_dialog(NULL));
}


int prepare_new_board_dialog() {
  SitePrefs sp;
  if (!glob.wmcc_pid) gtk_widget_set_sensitive(new_board_dialog("apply_bt"),FALSE);
  g_signal_connect(new_board_dialog("edit_bt"), "clicked",
                                    G_CALLBACK(switch_to_edit_dialog_callback),
                                    NULL);
  wmcc_site_prefs_set_default(&sp);
  multi_set_color_button(new_board_dialog("pp_bgcolor_bt"), sp.pp_bgcolor, 0);
  wmcc_site_prefs_destroy(&sp);
  return 0;
}

int validate_new_board_dialog()
{
  SitePrefs sp;
  wmcc_site_prefs_set_default(&sp);
  if (validate_site_name(gtk_entry_get_text(GTK_ENTRY(new_board_dialog("name"))), &sp, 1)) return -1;
  if (validate_backend_path(gtk_entry_get_text(GTK_ENTRY(new_board_dialog("backend_url"))), &sp)) return -1;
  if (validate_path_board_add(gtk_entry_get_text(GTK_ENTRY(new_board_dialog("path_board_add"))), &sp)) return -1;
  if (validate_board_post(gtk_entry_get_text(GTK_ENTRY(new_board_dialog("board_post"))), &sp)) return -1;
  if (validate_cookies(gtk_entry_get_text(GTK_ENTRY(new_board_dialog("cookies"))), &sp)) return -1;
  sp.backend_type = gtk_option_menu_get_history(GTK_OPTION_MENU(new_board_dialog("backend_type")));
  sp.board_check_delay = gtk_range_get_value(GTK_RANGE(new_board_dialog("hscale_board_check_delay")));
  multi_get_color_button(new_board_dialog("pp_bgcolor_bt"), &sp.pp_bgcolor);
  change_or_create_site_prefs(-1, &sp);
  //gtk_widget_hide(new_board_dialog(NULL));
  prefs_write_to_file(Prefs,stderr);
  return 0;
}

int run_new_board_dialog()
{
  if (prepare_new_board_dialog() == 0) {
    do {
      int rep = gtk_dialog_run(GTK_DIALOG(new_board_dialog(NULL)));
      printf("new_dialog_board return %d ok=%d\n", rep, GTK_RESPONSE_OK);
      if (rep != GTK_RESPONSE_OK) break;        
    } while (validate_new_board_dialog());
  }
  return GTK_RESPONSE_ACCEPT;
}

/* ---------------- pinnipede_dialog -------------------*/

int pfc_toggle_button(GtkWidget *win, const char *widget_name, int *value, int index, int finalize) {
  GtkWidget *w, *w_fb;
  if ((w=lookup_widget(win, widget_name))) {
    char *name_fb = str_printf("%s_fb", widget_name);
    w_fb = lookup_widget(win, name_fb);
    FREE_STRING(name_fb);
    if (finalize == 0) {
      multi_set_toggle_button(w, w_fb, *value, index);
    } else multi_get_toggle_button(w, value);
    return 1;
  } else return 0;
}

#define PFC_TOGGLE_BUTTON_G(pname) { pfc_toggle_button(dialog, #pname, &Prefs->pname, 0, finalize); }
#define PFC_TOGGLE_BUTTON_S(pname) { SitePrefs *sp;  for (i__=0; i__ < glob.nb_selected_sites; ++i__) \
                                       pfc_toggle_button(dialog, #pname, &Prefs->site[i__]->pname, i, finalize); }

int prepare_or_finalize_conf_dialog(GtkWidget *dialog, int finalize) {
  PFC_TOGGLE_BUTTON_G(pinnipede_open_on_start);
  PFC_TOGGLE_BUTTON_G(pp_use_classical_tabs);
  PFC_TOGGLE_BUTTON_G(pp_use_colored_tabs);
  PFC_TOGGLE_BUTTON_G(hungry_boitakon);
  PFC_TOGGLE_BUTTON_G(disable_xft_antialiasing);
  PFC_TOGGLE_BUTTON_S(mark_id_gaps);
  PFC_COLOR_BUTTON_S(pp_bgcolor);
  PFC_COLOR_BUTTON_S(pp_pp_fgcolor.opaque);
}

int prepare_pinnipede_dialog()
{
  int i; SitePrefs *sp;
  //gtk_widget_show(pinnipede_dialog("fnfamily_comboentry"));
  if (!glob.wmcc_pid) gtk_widget_set_sensitive(pinnipede_dialog("apply_bt"),FALSE);
  gtk_entry_set_text(GTK_ENTRY(pinnipede_dialog("fnfamily_comboentry")), Prefs->pp_fn_family);
  gtk_spin_button_set_value(GTK_SPIN_BUTTON(pinnipede_dialog("fnsize_spinbutton")), Prefs->pp_fn_size);
  multi_set_toggle_button(pinnipede_dialog("pp_auto_open"), 
                          pinnipede_dialog("pp_auto_open_fb"), Prefs->pinnipede_open_on_start, 0);
  multi_set_toggle_button(pinnipede_dialog("pp_use_classical_tabs"), 
                          pinnipede_dialog("pp_use_classical_tabs_fb"), Prefs->pp_use_classical_tabs, 0);
  multi_set_toggle_button(pinnipede_dialog("pp_use_colored_tabs"), 
                          pinnipede_dialog("pp_use_colored_tabs_fb"), Prefs->pp_use_colored_tabs, 0);
  multi_set_toggle_button(pinnipede_dialog("pp_hungry_boitakon"), 
                          pinnipede_dialog("pp_hungry_boitakon_fb"), Prefs->hungry_boitakon, 0);  
  multi_set_toggle_button(pinnipede_dialog("disable_aa"), 
                          pinnipede_dialog("disable_aa_fb"), Prefs->disable_xft_antialiasing, 0);  
  for (i=0; i < glob.nb_selected_sites && (sp = glob.selected_sites[i]); ++i) {
    multi_set_toggle_button(pinnipede_dialog("mark_id_gaps_checkbutton"), 
                            pinnipede_dialog("mark_id_gaps_checkbutton_fb"), sp->mark_id_gaps, i);
    multi_set_color_button(pinnipede_dialog("pp_bgcolor_bt"), sp->pp_bgcolor, i);
    multi_set_color_button(pinnipede_dialog("pp_fgcolor_bt"), sp->pp_fgcolor.opaque, i);
    multi_set_color_button(pinnipede_dialog("pp_trollscore_color_bt"), sp->pp_trollscore_color.opaque, i);
    multi_set_color_button(pinnipede_dialog("pp_login_color_bt"), sp->pp_login_color.opaque, i);
    multi_set_color_button(pinnipede_dialog("pp_tstamp_color_bt"), sp->pp_tstamp_color.opaque, i);
    multi_set_color_button(pinnipede_dialog("pp_useragent_color_bt"), sp->pp_useragent_color.opaque, i);
    multi_set_color_button(pinnipede_dialog("pp_url_color_bt"), sp->pp_url_color.opaque, i);
    multi_set_color_button(pinnipede_dialog("pp_visited_url_color_bt"), sp->pp_visited_url_color.opaque, i);
  }
  return 0;
}

int validate_pinnipede_dialog() 
{
  int i; SitePrefs *sp;
  ASSIGN_STRING_VAL(Prefs->pp_fn_family, gtk_entry_get_text(GTK_ENTRY(pinnipede_dialog("fnfamily_comboentry")))); 
  Prefs->pp_fn_size = gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(pinnipede_dialog("fnsize_spinbutton")));
  multi_get_toggle_button(pinnipede_dialog("pp_auto_open"), &Prefs->pinnipede_open_on_start);
  multi_get_toggle_button(pinnipede_dialog("pp_use_classical_tabs"), &Prefs->pp_use_classical_tabs);
  multi_get_toggle_button(pinnipede_dialog("pp_use_colored_tabs"), &Prefs->pp_use_colored_tabs);
  multi_get_toggle_button(pinnipede_dialog("pp_hungry_boitakon"), &Prefs->hungry_boitakon);
  multi_get_toggle_button(pinnipede_dialog("disable_aa"), &Prefs->disable_xft_antialiasing);
  for (i=0; i < glob.nb_selected_sites; ++i) {
    sp = glob.selected_sites[i];
    multi_get_toggle_button(pinnipede_dialog("mark_id_gaps_checkbutton"), &sp->mark_id_gaps);
    multi_get_color_button(pinnipede_dialog("pp_bgcolor_bt"), &sp->pp_bgcolor);
    multi_get_color_button(pinnipede_dialog("pp_fgcolor_bt"), &sp->pp_fgcolor.opaque);
    multi_get_color_button(pinnipede_dialog("pp_trollscore_color_bt"), &sp->pp_trollscore_color.opaque);
    multi_get_color_button(pinnipede_dialog("pp_login_color_bt"), &sp->pp_login_color.opaque);
    multi_get_color_button(pinnipede_dialog("pp_tstamp_color_bt"), &sp->pp_tstamp_color.opaque);
    multi_get_color_button(pinnipede_dialog("pp_useragent_color_bt"), &sp->pp_useragent_color.opaque);
    multi_get_color_button(pinnipede_dialog("pp_url_color_bt"), &sp->pp_url_color.opaque);
    multi_get_color_button(pinnipede_dialog("pp_visited_url_color_bt"), &sp->pp_visited_url_color.opaque);
  }
  printf("kldfskjfds\n");
  prefs_write_to_file(Prefs,stderr);
  printf("kldfskjfds\n");
  return 0;
}

int run_pinnipede_dialog() {
  if (prepare_pinnipede_dialog() == 0) {
    do {
      int rep = gtk_dialog_run(GTK_DIALOG(pinnipede_dialog(NULL)));
      if (rep != GTK_RESPONSE_OK) break;        
      printf("pinni finished\n");
    } while (validate_pinnipede_dialog());
  }
  gtk_widget_hide(GTK_WIDGET(pinnipede_dialog(NULL)));
  return 0;
}

/* ------------------ edit dialog -------------------*/
void colorize_edit_dialog() {
  /* should be made utf8 aware .. */
  GtkTextIter start, end;
  GtkWidget *view = edit_dialog("textview");
  GtkTextBuffer *buffer;
  static GtkTextTag *tags[6] = { NULL, };
  char *txt; // utf8 :/
  int lcount;
  buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW (view)); g_assert(buffer);
  if (tags[1] == 0) {
    tags[0] = NULL;
    tags[1] = gtk_text_buffer_create_tag(buffer, "comment_tag",
                                         "foreground", "#804000", NULL);
    tags[2] = gtk_text_buffer_create_tag(buffer, "string_tag",
                                         "foreground", "#008000", NULL);
    tags[3] = gtk_text_buffer_create_tag(buffer, "kwdot",
                                         "foreground", "#A0A0F0", NULL);
    tags[4] = gtk_text_buffer_create_tag(buffer, "kwlev1",
                                         "foreground", "blue", NULL);
    tags[5] = gtk_text_buffer_create_tag(buffer, "kwlev2",
                                         "foreground", "#0080A0", NULL);
  }
  lcount = 0;
  for (lcount = 0; lcount < gtk_text_buffer_get_line_count(buffer); ++lcount) {
    char *p; int state, i0, i1;
    gtk_text_buffer_get_iter_at_line(buffer, &start, lcount);
    gtk_text_buffer_get_iter_at_line(buffer, &end, lcount+1);
    txt = gtk_text_buffer_get_slice(buffer, &start, &end, TRUE);
    if ((p=strchr(txt, '#'))) {
      for (; *p; ++p) *p = 1;
    }
    for (p = txt, state = 0; *p; ++p) {
      if (*p == '"') { if (!(p > txt && *(p-1) == '\\')) state = 1-state; }
      if (state == 1 && *p != '"') *p = 2;
    }
    if ((p = strstr(txt, ": "))) {
      char *q = txt;
      state = 4;
      for (q = txt; q <= p; ++q) {
        if (*q == '.' || *q == ':') {
          *q = 3; state = 5;
        } else {
          *q = state;
        }
      }
    }
    int col;
    for (col = 0, state = 0, i0 = 0; col <= (int)strlen(txt); ++col) { /* on prend le 0 */
      int next_state = (txt[col] >= 1 && txt[col] <= 5) ? txt[col] : 0;
      p = txt + col;
      if (next_state != state) {
        if (state) {
          i1 = p-txt;
          gtk_text_buffer_get_iter_at_line_index(buffer, &start, lcount, i0);
          gtk_text_buffer_get_iter_at_line_index(buffer, &end, *p == 0 ? lcount+1 : lcount, *p == 0 ? 0 : i1);
          gtk_text_buffer_apply_tag (buffer, tags[state], &start, &end);
        }
        i0 = p-txt;
        state = next_state;
      }
    }
    free(txt);
  } 
}

int prepare_edit_dialog() {
  GtkTextIter start, end;
  GtkWidget *view = edit_dialog("textview");
  GtkTextBuffer *buffer;
  PangoFontDescription *ttfdesc;
  FILE *f;

  if (!glob.wmcc_pid) gtk_widget_set_sensitive(edit_dialog("apply_bt"),FALSE);

  buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW (view)); g_assert(buffer);
  gtk_text_buffer_get_bounds(buffer, &start, &end);
  gtk_text_buffer_delete(buffer, &start, &end);

  gtk_text_view_set_wrap_mode(GTK_TEXT_VIEW(view), GTK_WRAP_WORD);
  gtk_text_view_set_left_margin(GTK_TEXT_VIEW(view), 5);
  ttfdesc = pango_font_description_copy(GTK_WIDGET(view)->style->font_desc);
  pango_font_description_set_family (ttfdesc, "monospace");
  gtk_widget_modify_font(view, ttfdesc);

  if (!(f = fopen(glob.options_file, "r"))) {
    quick_message("uh ? cannot find %s", glob.options_file); return -1;
  } else {
    char rd[20];
    int cnt, lcnt = 1;
    int got_warning = 0;
    do {
      cnt = fread(rd, 1, sizeof rd - 1, f); 
      if (cnt > 0) {
        char *utf8, *p;
        gsize utf8_len;
        rd[cnt] = 0;
        for (p = rd; *p; ++p) if (*p == '\n') lcnt++;
        utf8 = g_locale_to_utf8(rd, -1, NULL, &utf8_len, NULL);
        if (!utf8 || utf8_len == 0) {
          if (!got_warning) {
            quick_message("gtk could not convert your option file to utf8 -- "
                          "check your locales, check for fucking caracters in your file (around line %d)..\n"
                          "I am now going to patiently strip all non ascii caracters. You have been warned.", lcnt);
            got_warning = 1;
          }
          for (p = rd; *p; ++p) { if (*p < 0) *p = ' '; }
          utf8 = g_locale_to_utf8(rd, -1, NULL, &utf8_len, NULL); g_assert(utf8); g_assert(utf8_len);
        }
        //gtk_text_buffer_get_bounds(buffer, &start, &end);
        gtk_text_buffer_insert_at_cursor(buffer, utf8, utf8_len);
        g_free(utf8);
      }
    } while (cnt == sizeof rd - 1);
  }
  gtk_text_buffer_insert_at_cursor(buffer, "\n\n# append your new options here (or edit the values above)\n\n", -1);
  colorize_edit_dialog();

  gtk_text_buffer_get_bounds(buffer, &start, &end);
  GtkTextMark *end_mark =  gtk_text_buffer_create_mark(buffer, "end", &end, 0); g_assert(end_mark);
  gtk_text_view_scroll_mark_onscreen(GTK_TEXT_VIEW(view), end_mark);
  return 0;
}

int validate_edit_dialog() {
  printf("saving prefs.. syncing..\n");
  return 0;
}

int run_edit_dialog() {
  int rep = GTK_RESPONSE_ACCEPT; 
  if (prepare_edit_dialog() == 0) {
    do {
      printf("run !\n");
      rep = gtk_dialog_run(GTK_DIALOG(edit_dialog(NULL)));
      if (rep != GTK_RESPONSE_OK) {
        return rep;
      }
      if (validate_edit_dialog() == 0) {
        return GTK_RESPONSE_OK;
        break;
      }
    } while (1);
  }
  printf("resp : %d\n", rep);
  return rep;
}

int run_bronson_wizard() {
  g_signal_connect ((gpointer) bronson_wizard("wizard_new_board_bt"), "clicked",
                    G_CALLBACK (run_new_board_dialog), NULL);
  g_signal_connect ((gpointer) bronson_wizard("wizard_new_feed_bt"), "clicked",
                    G_CALLBACK (run_new_board_dialog), NULL);
  g_signal_connect ((gpointer) bronson_wizard("wizard_edit_options_bt"), "clicked",
                    G_CALLBACK (run_edit_dialog), NULL);

  int rep = gtk_dialog_run(GTK_DIALOG(bronson_wizard(NULL)));
  printf("rep = %d\n",rep);
  return 0;
}

enum { SITE_ENABLED_COLUMN, SITE_NAME_COLUMN, BACKEND_COLUMN, N_COLUMN };

/*static void
tree_selection_changed_cb (GtkTreeSelection *selection, gpointer data)
{
        GtkTreeIter iter;
        GtkTreeModel *model;
        gchar *author;

        if (gtk_tree_selection_get_selected (selection, &model, &iter))
        {
                gtk_tree_model_get (model, &iter, AUTHOR_COLUMN, &author, -1);

                g_print ("You selected a book by %s\n", author);

                g_free (author);
        }
}
*/

struct SiteListModel {
  GtkListStore *store;
  GtkTreeSelection *select;
};


void sitelist_remove_cb(GtkWidget *button, struct SiteListModel *mdl) {
  GtkTreeIter iter;
  unsigned count = 0, j;
  if (gtk_tree_model_get_iter_first(GTK_TREE_MODEL(mdl->store), &iter)) {
    do {
      gboolean enabled;
      gchar *site_name;
      gtk_tree_model_get(GTK_TREE_MODEL(mdl->store), &iter, 
                         SITE_NAME_COLUMN, &site_name,
                         SITE_ENABLED_COLUMN, &enabled,
                         -1);
      if (gtk_tree_selection_iter_is_selected(mdl->select,&iter)) {
        printf("%s [%d] is selected!\n", site_name, enabled);
        wmcc_site_prefs_destroy(Prefs->site[count]);
        Prefs->site[count] = NULL;
      }
      g_free(site_name);
      ++count;
    } while (gtk_tree_model_iter_next(GTK_TREE_MODEL(mdl->store), &iter));
  }
  for (count = 0, j=0; count < Prefs->nb_sites; ++count) {
    if (Prefs->site[count]) {
      Prefs->site[j++] = Prefs->site[count];
    }
  }
  Prefs->nb_sites = j;
  gtk_dialog_response(GTK_DIALOG(sitelist_dialog(NULL)),1); 
}

void sitelist_edit_cb(GtkWidget *button, struct SiteListModel *mdl) {
  GtkTreeIter iter;
  unsigned count = 0, count2 = 0;
  glob.nb_selected_sites = 0;
  if (gtk_tree_model_get_iter_first(GTK_TREE_MODEL(mdl->store), &iter)) {
    do {
      if (gtk_tree_selection_iter_is_selected(mdl->select,&iter)) {
        glob.selected_sites[glob.nb_selected_sites++] = Prefs->site[count];
        count2++;
      }
      count++;
    } while (gtk_tree_model_iter_next(GTK_TREE_MODEL(mdl->store), &iter));
  }
  if (count2) {
    run_pinnipede_dialog();
    gtk_dialog_response(GTK_DIALOG(sitelist_dialog(NULL)),1);
  }
}

int prepare_sitelist_dialog() {
  static struct SiteListModel mdl = {0,};
  static isinit = 0;
  GtkTreeIter   iter;
  GtkCellRenderer *renderer;
  GtkTreeViewColumn *column;
  int i;
  if (isinit) gtk_list_store_clear(mdl.store);
  else mdl.store = gtk_list_store_new (N_COLUMN, G_TYPE_BOOLEAN, G_TYPE_STRING, G_TYPE_STRING);
  for (i = 0; i < Prefs->nb_sites; ++i) {
    gtk_list_store_append (mdl.store, &iter);
    gtk_list_store_set(mdl.store, &iter, 
                       SITE_ENABLED_COLUMN, Prefs->site[i]->check_board,
                       SITE_NAME_COLUMN, Prefs->site[i]->all_names[0],
                       BACKEND_COLUMN, Prefs->site[i]->site_root, -1);
  }
  if (!isinit) {
    gtk_tree_view_set_model(GTK_TREE_VIEW(sitelist_dialog("treeview")), GTK_TREE_MODEL(mdl.store));
    renderer = gtk_cell_renderer_toggle_new();  
    column = gtk_tree_view_column_new_with_attributes ("Enabled",
                                                       renderer,
                                                       "active", SITE_ENABLED_COLUMN,
                                                       NULL);
    gtk_tree_view_append_column (GTK_TREE_VIEW (sitelist_dialog("treeview")), column);
    
    renderer = gtk_cell_renderer_text_new ();
    column = gtk_tree_view_column_new_with_attributes ("Site Name",
                                                       renderer,
                                                       "text", SITE_NAME_COLUMN,
                                                       NULL);
    gtk_tree_view_append_column (GTK_TREE_VIEW (sitelist_dialog("treeview")), column);
    
    renderer = gtk_cell_renderer_text_new ();
    column = gtk_tree_view_column_new_with_attributes ("Backend",
                                                       renderer,
                                                       "text", BACKEND_COLUMN,
                                                       NULL);
    gtk_tree_view_append_column (GTK_TREE_VIEW (sitelist_dialog("treeview")), column);
    mdl.select = gtk_tree_view_get_selection (GTK_TREE_VIEW(sitelist_dialog("treeview")));
    gtk_tree_selection_set_mode(mdl.select, GTK_SELECTION_MULTIPLE);
    g_signal_connect(G_OBJECT(sitelist_dialog("remove_bt")), "clicked",
                     G_CALLBACK(sitelist_remove_cb),
                     (gpointer)&mdl);
    g_signal_connect(G_OBJECT(sitelist_dialog("edit_bt")), "clicked",
                     G_CALLBACK(sitelist_edit_cb),
                     (gpointer)&mdl);
  }
  isinit = 1;
  return 0;
}

int run_sitelist_dialog() {
  int rep;
  do {
    prepare_sitelist_dialog();
    rep = gtk_dialog_run(GTK_DIALOG(sitelist_dialog(NULL)));
    printf("run_sitelist_dialog: response: %d\n", rep);
    
  } while (rep == 1);
  return 0;
}

int
main (int argc, char *argv[])
{
  enum { ADD_NEW_BOARD, ADD_NEW_RSS, CONFIG_PINNI, ABORT_WMCCC, EDIT_CONFIG, BRONSON_WIZARD, SITELIST } action;
#ifdef ENABLE_NLS_POUR_WMCCC
  bindtextdomain (GETTEXT_PACKAGE, PACKAGE_LOCALE_DIR);
  bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
  textdomain (GETTEXT_PACKAGE);
#endif

  glob.current_site = 0;
  glob.main_win = NULL;
  glob.nb_selected_sites = 0;
  //  gtk_set_locale ();

  umask(077);
  gtk_set_locale ();
  gtk_init (&argc, &argv);

  add_pixmap_directory (WMCCDATADIR);

  glob.modif_widget_color.red = 32000;
  glob.modif_widget_color.green = 000;
  glob.modif_widget_color.blue = 000;
  gdk_colormap_alloc_color(gdk_colormap_get_system(), &glob.modif_widget_color, FALSE, TRUE);

  if (argc <= 1) {
    printf("syntaxe: \n wmccc -o optionfile -wizard\n");
    exit(1);
  }

  if (strcmp(argv[1], "-wmccpid")==0) {
    g_print("wmc³ launched from wmc²\n"); g_assert(argc == 5);
    glob.wmcc_pid = atoi(argv[2]);
    glob.options_file = strdup(argv[3]);
    glob.tmp_options_file = strdup(argv[4]);
    argc-=4; argv+=4;
  } else {
    glob.wmcc_pid = 0;    
    if (argc < 2 || strcmp(argv[1],"-o")) {
      g_print("missing -o option_file");
      return -1;
    } 
    glob.options_file = strdup(argv[2]);
    glob.tmp_options_file = NULL;
    argc -= 2; argv += 2;
  }

  Prefs = NULL;
  read_prefs();

  //action = ABORT_WMCCC;
  action = SITELIST;
  if (argc > 1) {
    if (strcasecmp(argv[1], "-new-board")==0) {
      action = ADD_NEW_BOARD; argc--; argv++;
    } else if (strcasecmp(argv[1], "-new-rss")==0) {
      action = ADD_NEW_RSS; argc--; argv++;
    } else if (strcasecmp(argv[1], "-config-pinni")==0) {
      action = CONFIG_PINNI; argc--; argv++;
    } else if (strcasecmp(argv[1], "-edit")==0) {
      action = EDIT_CONFIG; argc--; argv++;
    } else if (strcasecmp(argv[1], "-wizard")==0 || strcasecmp(argv[1], "-charles-bronson")==0) {
      action = BRONSON_WIZARD; argc--; argv++;
    } 
  }

  while (argc > 1 && strcasecmp(argv[1], "-site")==0) {
    assert(argc > 2);
    char *sname = argv[2];
    SitePrefs *sp =  wmcc_prefs_find_site(Prefs, sname);
    if (sp) {
      glob.selected_sites[glob.nb_selected_sites++] = sp;
    }
    argc -=2; argv += 2;
  }


  /* petite bidouille pour les alias de sites et le nom de site */
  {
    int snum;
    for (snum = 0; snum < Prefs->nb_sites; snum++) {
      SitePrefs *sp = Prefs->site[snum];
      int i;
      sp->all_names = g_renew(char *, sp->all_names, MAX(4, sp->nb_names));
      for (i = sp->nb_names; i < 4; i++) sp->all_names[i] = NULL;
      sp->site_name = NULL;
    }
  }

  switch (action) 
  {
    case ABORT_WMCCC:
    case ADD_NEW_RSS:
      break;
    case ADD_NEW_BOARD: {
      run_new_board_dialog();
    } break;
    case CONFIG_PINNI: {
      run_pinnipede_dialog();
    } break;
    case EDIT_CONFIG: run_edit_dialog(); break;
  case BRONSON_WIZARD: run_bronson_wizard(); break;
  case SITELIST: 
    run_sitelist_dialog(); break;
    default: g_assert(0);
  }
  //gtk_main();
  return 0;
}

