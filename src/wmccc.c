/*
 * Initial main.c file generated by Glade. Edit as required.
 * Glade will not overwrite this file.
 */

/*
  petite remarque sur la gestion de la memoire dans wmccc: on utilise un
  garbage-collector très puissant. Pour le mettre en action, il suffit
  d'appeler exit(0). Side-effect: met fin au programme.
*/

#ifdef HAVE_CONFIG_H
#  include <config.h>
#endif

#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>
#define GLOBALS_HERE
#define WMCCC_C
#include "wmccc.h"
#include "wmccc_interface.h"
#include "wmccc_support.h"

int run_edit_dialog();

GdkColor*
irgb_to_gdkcolor(unsigned icol) {
  static GdkColor color;
  color.red   = ((icol & 0xff0000) >> 16) * 256+ 127;
  color.green = ((icol & 0x00ff00) >> 8) * 256 + 127;
  color.blue  = ((icol & 0x0000ff)     ) * 256 + 127;
    
  gdk_colormap_alloc_color( gdk_colormap_get_system(), &color, FALSE, TRUE);
  return &color;
}

unsigned gdkcolor_to_irgb(GdkColor *c) {
  g_assert(c);
  return ((c->red/256) << 16) + ((c->green/256) << 8) + (c->blue/256);
}

GtkWidget *messagebox_dialog(char *widget) {
  static GtkWidget *d = NULL;
  if (!d) { d = create_messagebox_dialog(); g_assert(d); }
  if (widget == NULL) 
    return d;
  else {
    GtkWidget *w = lookup_widget(d, widget); g_assert(w); 
    return w;
  }
}

GtkWidget *new_board_dialog(char *widget) {
  static GtkWidget *d = NULL;
  if (!d) { d = create_new_board_dialog(); g_assert(d); }
  if (widget == NULL) 
    return d;
  else {
    GtkWidget *w = lookup_widget(d, widget); g_assert(w);    
    return w;
  }
}
GtkWidget *pinnipede_dialog(char *widget) {
  static GtkWidget *d = NULL;
  if (!d) { d = create_pinnipede_dialog(); g_assert(d); }
  if (widget == NULL) 
    return d;
  else {
    GtkWidget *w = lookup_widget(d, widget); g_assert(w);
    return w;
  }
}

GtkWidget *edit_dialog(char *widget) {
  static GtkWidget *d = NULL;
  if (!d) { d = create_edit_dialog(); g_assert(d); }
  if (widget == NULL) 
    return d;
  else {
    GtkWidget *w = lookup_widget(d, widget); g_assert(w);
    return w;
  }
}

GtkWidget *bronson_wizard(char *widget) {
  static GtkWidget *d = NULL;
  if (!d) { d = create_bronson_wizard(); g_assert(d); }
  if (widget == NULL) 
    return d;
  else {
    GtkWidget *w = lookup_widget(d, widget); g_assert(w);
    return w;
  }
}

/* lit out relit les prefs */
int read_prefs() {
  char *err;
  if (Prefs && glob.nb_selected_sites) { 
    quick_message("you should not be able to do that!"); exit(1); 
  }
  if (Prefs) wmcc_prefs_destroy(Prefs);
  Prefs = g_new0(GeneralPrefs, 1);
  wmcc_prefs_set_default(Prefs);

  err = wmcc_prefs_read_options(Prefs, glob.options_file,1);
  if (err || Prefs->nb_sites == 0) {
    if (!err && Prefs->nb_sites == 0) err = "no site..";
    quick_message("error reading %s: %s", glob.options_file, err); return 2;
  }
  return 0;
}

int new_options_from_string(const char *s) {
  FILE *f;
  char *err;
  int old_nb_site = Prefs->nb_sites, i;
  char *congratulations = NULL;
  if (!s || strlen(s) == 0) return -1;
  f = open_wfile(glob.tmp_options_file);
  if (!f) {
    quick_message("could not create temporary file '%s' : %s", glob.tmp_options_file, strerror(errno));
    return -1;
  }
  if (fputs(s,f) == EOF) {
    quick_message("could not create temporary file '%s' : %s", glob.tmp_options_file, strerror(errno));
    return -1;
  }
  fclose(f);
  err = wmcc_prefs_read_options(Prefs, glob.tmp_options_file, 1);
  if (err) {
    g_print("error while parsing preferences: %s\n", err);
    if (read_prefs() != 0) { // on remet celles d'avant
      fprintf(stderr, "ça commence a bien faire.\n"); exit(1); 
    }    
    return 2;
  }
  for (i = old_nb_site; i < Prefs->nb_sites; ++i) {
    congratulations = str_cat_printf(congratulations, "%s%s", Prefs->site[i]->site_name, (i?"":", "));
  }
  quick_message("Congratulations !\nThe options were successfully parsed\n%d sites were added: %s",
                Prefs->nb_sites-old_nb_site,congratulations);
  free(congratulations);
  return 0;
}

/* Function to open a dialog box displaying the message provided. */
void quick_message(gchar *message_fmt, ...) {
  va_list ap;
  GtkWidget *label;
  char s[1024];
  va_start(ap, message_fmt);
  vsnprintf(s,1024,message_fmt,ap);
  va_end(ap);
  label = messagebox_dialog("messagebox_label"); 
  gtk_label_set_text(GTK_LABEL(messagebox_dialog("messagebox_label")), s);
  gtk_dialog_run (GTK_DIALOG(messagebox_dialog(NULL)));
}

GtkWidget *colorselection_dialog() {
  static GtkWidget *d = NULL;
  if (!d) { d = gtk_color_selection_dialog_new("select a color"); g_assert(d); }
  return d;
}

int change_or_create_site_prefs(int sid, SitePrefs *sp0) {
  if (sid == -1 || sid > Prefs->nb_sites-1) {
    sid = Prefs->nb_sites++;
    if (Prefs->nb_sites == MAX_SITES) {
      quick_message("too much sites!");
      return -1;
    }  
    Prefs->site[sid] = g_new(SitePrefs,1);
    wmcc_site_prefs_set_default(Prefs->site[sid]);
  }
  wmcc_site_prefs_copy(Prefs->site[sid], sp0);
  return 0;
}

/* ------ widget management ------*/

typedef struct TouchedInfo_ {
  int touched;
  int multivalued;
  GtkWidget *feedback_label;
} TouchedInfo;

void
widget_value_changed_callback(GtkWidget *w, TouchedInfo *ti) {
  g_assert(ti);
  if (ti->touched == -1) return;
  printf("ptouiched=%d\n", ti->touched);
  (ti->touched)++;
  if (ti->feedback_label) {
    gtk_widget_modify_fg(ti->feedback_label, GTK_STATE_NORMAL, &glob.modif_widget_color);
    gtk_widget_modify_text(w, GTK_STATE_NORMAL, &glob.modif_widget_color);
    gtk_label_set_text(GTK_LABEL(ti->feedback_label), "[modified]");
  }
  /*gtk_widget_modify_bg(w, GTK_STATE_NORMAL, &glob.modif_widget_color);
  gtk_widget_modify_bg(w, GTK_STATE_SELECTED, &glob.modif_widget_color);
  gtk_button_set_label(GTK_BUTTON(w), "plop!");*/
}

/* ---------------- toggle buttons ----------------*/
void multi_set_toggle_button(GtkWidget *w, GtkWidget *feedback_label, int value, int count) {
  TouchedInfo *ti = NULL;
  printf("multi set toggle : count = %d, val = %d\n",count,value);
  if (count == 0) {
    ti = g_new0(TouchedInfo,1); 
    ti->feedback_label = feedback_label; ti->multivalued = 0;
    g_object_set_data(G_OBJECT(w), "touched", ti);
    g_signal_connect ((gpointer) w, "toggled",
                      G_CALLBACK (widget_value_changed_callback),
                      g_object_get_data(G_OBJECT(w), "touched"));
    ti->touched = -1;
    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(w), value);
  } else {
    ti = g_object_get_data(G_OBJECT(w), "touched");
    if (value != gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(w)) && !ti->multivalued) 
      ti->multivalued = 1;
    /*    if (!gtk_toggle_button_get_inconsistent(GTK_TOGGLE_BUTTON(w)) &&
        gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(w)) != value) {
      gtk_toggle_button_set_inconsistent(GTK_TOGGLE_BUTTON(w), TRUE);
    }
    */
  }
  if (ti->feedback_label) {
    if (ti->multivalued) {
      gtk_widget_modify_fg(ti->feedback_label, GTK_STATE_NORMAL, &glob.modif_widget_color);
    } else gtk_widget_set_style (ti->feedback_label, NULL);
    gtk_label_set_text(GTK_LABEL(ti->feedback_label), ti->multivalued ? "[different values!]" : "[unchanged]");
  }
  ti->touched = 0;
}

int multi_get_toggle_button(GtkWidget *w, gboolean *value) {
  TouchedInfo *ti = g_object_get_data(G_OBJECT(w), "touched"); g_assert(ti);
  if (ti->touched) {
    *value = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(w));
  }
  return ti->touched;
}

/* ------------------- color button -------------------------- */

void color_button_update_color(GtkWidget *w, GdkColor *c, int value_store) {
  if (value_store) g_object_set_data(G_OBJECT(w), "value", GINT_TO_POINTER(gdkcolor_to_irgb(c)));
  gtk_widget_modify_bg(w, GTK_STATE_PRELIGHT, c);
  gtk_widget_modify_bg(w, GTK_STATE_NORMAL, c);
}

void color_button_clicked_callback(GtkWidget *w, TouchedInfo *ti) {
  GdkColor c;
  
  GtkWidget *colorsel = GTK_COLOR_SELECTION_DIALOG(colorselection_dialog())->colorsel;
  
  gtk_color_selection_set_current_color(GTK_COLOR_SELECTION(colorsel), 
                                        irgb_to_gdkcolor(GPOINTER_TO_INT(g_object_get_data(G_OBJECT(w), "value"))));
  gtk_color_selection_set_has_palette(GTK_COLOR_SELECTION(colorsel), TRUE);
  int rep = gtk_dialog_run(GTK_DIALOG(colorselection_dialog()));

  gtk_color_selection_get_current_color(GTK_COLOR_SELECTION(colorsel), &c);
  gtk_widget_hide(GTK_WIDGET(colorselection_dialog()));
  
  if (rep == GTK_RESPONSE_OK) {
    printf("colorselection_dialog returned %d %d/%d/%d\n", rep, c.red, c.green, c.blue);
    color_button_update_color(w,&c,1);
    widget_value_changed_callback(w,ti);
  }
}

void multi_set_color_button(GtkWidget *w, unsigned value, int count) {
  TouchedInfo *ti = NULL;
  printf("multi set color button : count = %d, val = %d\n",count,value);
  if (count == 0) {
    ti = g_new0(TouchedInfo,1); 
    ti->feedback_label = GTK_BIN(w)->child; ti->multivalued = 0;
    g_object_set_data(G_OBJECT(w), "touched", ti);
    g_signal_connect ((gpointer) w, "clicked",
                      G_CALLBACK (color_button_clicked_callback),
                      g_object_get_data(G_OBJECT(w), "touched"));
    ti->touched = -1;
    printf("bgcolor : %06x\n", value);
    //gtk_widget_modify_text(ti->feedback_label, GTK_STATE_NORMAL, irgb_to_gdkcolor(value));
    color_button_update_color(w, irgb_to_gdkcolor(value), 1);
  } else {
    ti = g_object_get_data(G_OBJECT(w), "touched");
    if (value != (unsigned)GPOINTER_TO_INT(g_object_get_data(G_OBJECT(w), "value")) && !ti->multivalued) {
      gtk_widget_set_style (ti->feedback_label, NULL);
      ti->multivalued = 1;
    }
  }
  if (ti->multivalued) {
    //gtk_widget_set_style(w, NULL); // marche pô 
    color_button_update_color(w, irgb_to_gdkcolor(0x808080), 0);
  }
  gtk_label_set_text(GTK_LABEL(ti->feedback_label), ti->multivalued ? "[*val!]" : "[unchanged]");
  ti->touched = 0;
}

int multi_get_color_button(GtkWidget *w, unsigned *value) {
  TouchedInfo *ti = g_object_get_data(G_OBJECT(w), "touched"); g_assert(ti);
  if (ti->touched) {
    *value =  GPOINTER_TO_INT(g_object_get_data(G_OBJECT(w), "value"));
    printf("multi_get_color_button got %06x\n", *value);
  }
  return ti->touched;
}


int validate_cookies(const char *cookies, SitePrefs *sp) { 
  ASSIGN_STRING_VAL(sp->user_cookie, cookies); return 0; 
}
int validate_board_post(const char *s, SitePrefs *sp) { ASSIGN_STRING_VAL(sp->board_post, s); return 0; }
int validate_path_board_add(const char *s, SitePrefs *sp) { ASSIGN_STRING_VAL(sp->path_board_add, s); return 0; }
int validate_backend_path(const char *s_, SitePrefs *sp) {
  int err = 0;
  char *s = strdup(s_), *p;
  if (str_is_empty(s)) { quick_message("Empty backend path"); return -1; }
  url_au_coiffeur(s,0);
  p = strrchr(s,'/');
  FREE_STRING(sp->site_root); FREE_STRING(sp->site_path); FREE_STRING(sp->path_board_backend);
  if (p) {
    *p = 0;
    option_site_root(s, sp, 0);
    if (sp->site_root) {
      ASSIGN_STRING_VAL(sp->path_board_backend, p);
    }
  } 
  err = (sp->site_root == NULL);
  free(s);
  if (err) {
    quick_message("malformed backend url");
    return -1;
  } else return 0;
}
int validate_site_name(const char *s, SitePrefs *sp, int check_new_site) {
  if (str_is_empty(s)) { quick_message("Empty site name"); return -1; }
  if (check_new_site) {
    char *s2 = strdup(s); str_trim(s2);
    int i;
    for (i=0; i < Prefs->nb_sites; ++i) {
      int j;
      assert(Prefs->site[i]);
      for (j=0; j < Prefs->site[i]->nb_names; ++j)
        if (strcasecmp(Prefs->site[i]->all_names[j], s) == 0) {
          printf("oups\n");
          quick_message("there is already a site called %s", s); return -1;
        }
    }
    free(s2);
  }
  if (sp->all_names == NULL) { sp->all_names = g_new0(char*,4); }
  ASSIGN_STRING_VAL(sp->all_names[0], s);
  return 0;
}

void
switch_to_edit_dialog_callback(GtkButton *button, gpointer user_data) {
  int rep;
  GtkWidget *win = gtk_widget_get_toplevel(GTK_WIDGET(button)); g_assert(win);
  //gtk_widget_hide(win);
  rep = run_edit_dialog();
  printf("rep = %d\n",rep);
  if (rep == GTK_RESPONSE_OK) { 
    printf("resp ok\n");
    gtk_dialog_response(GTK_DIALOG(new_board_dialog(NULL)),GTK_RESPONSE_ACCEPT); 
  } //else gtk_widget_show(win);
  gtk_widget_hide(edit_dialog(NULL));
}


int prepare_new_board_dialog() {
  SitePrefs sp;
  if (!glob.wmcc_pid) gtk_widget_set_sensitive(new_board_dialog("apply_bt"),FALSE);
  g_signal_connect(new_board_dialog("edit_bt"), "clicked",
                                    G_CALLBACK(switch_to_edit_dialog_callback),
                                    NULL);
  wmcc_site_prefs_set_default(&sp);
  multi_set_color_button(new_board_dialog("pp_bgcolor_bt"), sp.pp_bgcolor, 0);
  wmcc_site_prefs_destroy(&sp);
  return 0;
}

int validate_new_board_dialog()
{
  SitePrefs sp;
  wmcc_site_prefs_set_default(&sp);
  if (validate_site_name(gtk_entry_get_text(GTK_ENTRY(new_board_dialog("name"))), &sp, 1)) return -1;
  if (validate_backend_path(gtk_entry_get_text(GTK_ENTRY(new_board_dialog("backend_url"))), &sp)) return -1;
  if (validate_path_board_add(gtk_entry_get_text(GTK_ENTRY(new_board_dialog("path_board_add"))), &sp)) return -1;
  if (validate_board_post(gtk_entry_get_text(GTK_ENTRY(new_board_dialog("board_post"))), &sp)) return -1;
  if (validate_cookies(gtk_entry_get_text(GTK_ENTRY(new_board_dialog("cookies"))), &sp)) return -1;
  sp.backend_type = gtk_option_menu_get_history(GTK_OPTION_MENU(new_board_dialog("backend_type")));
  sp.board_check_delay = gtk_range_get_value(GTK_RANGE(new_board_dialog("hscale_board_check_delay")));
  multi_get_color_button(new_board_dialog("pp_bgcolor_bt"), &sp.pp_bgcolor);
  change_or_create_site_prefs(-1, &sp);
  //gtk_widget_hide(new_board_dialog(NULL));
  prefs_write_to_file(Prefs,stderr);
  return 0;
}

void run_new_board_dialog()
{
  if (prepare_new_board_dialog() == 0) {
    do {
      int rep = gtk_dialog_run(GTK_DIALOG(new_board_dialog(NULL)));
      printf("new_dialog_board return %d ok=%d\n", rep, GTK_RESPONSE_OK);
      if (rep != GTK_RESPONSE_OK) break;        
    } while (validate_new_board_dialog());
  }
  return GTK_RESPONSE_ACCEPT;
}

/* ---------------- pinnipede_dialog -------------------*/

int prepare_pinnipede_dialog()
{
  int i; SitePrefs *sp;
  //gtk_widget_show(pinnipede_dialog("fnfamily_comboentry"));
  if (!glob.wmcc_pid) gtk_widget_set_sensitive(pinnipede_dialog("apply_bt"),FALSE);
  gtk_entry_set_text(GTK_ENTRY(pinnipede_dialog("fnfamily_comboentry")), Prefs->pp_fn_family);
  gtk_spin_button_set_value(GTK_SPIN_BUTTON(pinnipede_dialog("fnsize_spinbutton")), Prefs->pp_fn_size);
  for (i=0; i < glob.nb_selected_sites && (sp = glob.selected_sites[i]); ++i) {
    multi_set_toggle_button(pinnipede_dialog("mark_id_gaps_checkbutton"), 
                            pinnipede_dialog("mark_id_gaps_checkbutton_fb"), sp->mark_id_gaps, i);
    multi_set_color_button(pinnipede_dialog("pp_bgcolor_bt"), sp->pp_bgcolor, i);
    multi_set_color_button(pinnipede_dialog("pp_fgcolor_bt"), sp->pp_fgcolor.opaque, i);
    multi_set_color_button(pinnipede_dialog("pp_trollscore_color_bt"), sp->pp_trollscore_color.opaque, i);
    multi_set_color_button(pinnipede_dialog("pp_login_color_bt"), sp->pp_login_color.opaque, i);
    multi_set_color_button(pinnipede_dialog("pp_tstamp_color_bt"), sp->pp_tstamp_color.opaque, i);
    multi_set_color_button(pinnipede_dialog("pp_useragent_color_bt"), sp->pp_useragent_color.opaque, i);
    multi_set_color_button(pinnipede_dialog("pp_url_color_bt"), sp->pp_url_color.opaque, i);
    multi_set_color_button(pinnipede_dialog("pp_visited_url_color_bt"), sp->pp_visited_url_color.opaque, i);
  }
  return 0;
}

int validate_pinnipede_dialog() 
{
  int i; SitePrefs *sp;
  ASSIGN_STRING_VAL(Prefs->pp_fn_family, gtk_entry_get_text(GTK_ENTRY(pinnipede_dialog("fnfamily_comboentry")))); 
  Prefs->pp_fn_size = gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(pinnipede_dialog("fnsize_spinbutton")));
  for (i=0; i < glob.nb_selected_sites; ++i) {
    sp = glob.selected_sites[i];
    multi_get_toggle_button(pinnipede_dialog("mark_id_gaps_checkbutton"), &sp->mark_id_gaps);
    multi_get_color_button(pinnipede_dialog("pp_bgcolor_bt"), &sp->pp_bgcolor);
    multi_get_color_button(pinnipede_dialog("pp_fgcolor_bt"), &sp->pp_fgcolor.opaque);
    multi_get_color_button(pinnipede_dialog("pp_trollscore_color_bt"), &sp->pp_trollscore_color.opaque);
    multi_get_color_button(pinnipede_dialog("pp_login_color_bt"), &sp->pp_login_color.opaque);
    multi_get_color_button(pinnipede_dialog("pp_tstamp_color_bt"), &sp->pp_tstamp_color.opaque);
    multi_get_color_button(pinnipede_dialog("pp_useragent_color_bt"), &sp->pp_useragent_color.opaque);
    multi_get_color_button(pinnipede_dialog("pp_url_color_bt"), &sp->pp_url_color.opaque);
    multi_get_color_button(pinnipede_dialog("pp_visited_url_color_bt"), &sp->pp_visited_url_color.opaque);
  }
  prefs_write_to_file(Prefs,stderr);
  return 0;
}

/* ------------------ edit dialog -------------------*/
void colorize_edit_dialog() {
  /* should be made utf8 aware .. */
  GtkTextIter start, end;
  GtkWidget *view = edit_dialog("textview");
  GtkTextBuffer *buffer;
  static GtkTextTag *tags[6] = { NULL, };
  char *txt; // utf8 :/
  int lcount;
  buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW (view)); g_assert(buffer);
  if (tags[1] == 0) {
    tags[0] = NULL;
    tags[1] = gtk_text_buffer_create_tag(buffer, "comment_tag",
                                         "foreground", "#804000", NULL);
    tags[2] = gtk_text_buffer_create_tag(buffer, "string_tag",
                                         "foreground", "#008000", NULL);
    tags[3] = gtk_text_buffer_create_tag(buffer, "kwdot",
                                         "foreground", "#A0A0F0", NULL);
    tags[4] = gtk_text_buffer_create_tag(buffer, "kwlev1",
                                         "foreground", "blue", NULL);
    tags[5] = gtk_text_buffer_create_tag(buffer, "kwlev2",
                                         "foreground", "#0080A0", NULL);
  }
  lcount = 0;
  for (lcount = 0; lcount < gtk_text_buffer_get_line_count(buffer); ++lcount) {
    char *p; int state, i0, i1;
    gtk_text_buffer_get_iter_at_line(buffer, &start, lcount);
    gtk_text_buffer_get_iter_at_line(buffer, &end, lcount+1);
    txt = gtk_text_buffer_get_slice(buffer, &start, &end, TRUE);
    if ((p=strchr(txt, '#'))) {
      for (; *p; ++p) *p = 1;
    }
    for (p = txt, state = 0; *p; ++p) {
      if (*p == '"') { if (!(p > txt && *(p-1) == '\\')) state = 1-state; }
      if (state == 1 && *p != '"') *p = 2;
    }
    if ((p = strstr(txt, ": "))) {
      char *q = txt;
      state = 4;
      for (q = txt; q <= p; ++q) {
        if (*q == '.' || *q == ':') {
          *q = 3; state = 5;
        } else {
          *q = state;
        }
      }
    }
    int col;
    for (col = 0, state = 0, i0 = 0; col <= (int)strlen(txt); ++col) { /* on prend le 0 */
      int next_state = (txt[col] >= 1 && txt[col] <= 5) ? txt[col] : 0;
      p = txt + col;
      if (next_state != state) {
        if (state) {
          i1 = p-txt;
          gtk_text_buffer_get_iter_at_line_index(buffer, &start, lcount, i0);
          gtk_text_buffer_get_iter_at_line_index(buffer, &end, *p == 0 ? lcount+1 : lcount, *p == 0 ? 0 : i1);
          gtk_text_buffer_apply_tag (buffer, tags[state], &start, &end);
        }
        i0 = p-txt;
        state = next_state;
      }
    }
    free(txt);
  } 
}

int prepare_edit_dialog() {
  GtkTextIter start, end;
  GtkWidget *view = edit_dialog("textview");
  GtkTextBuffer *buffer;
  PangoFontDescription *ttfdesc;
  FILE *f;

  if (!glob.wmcc_pid) gtk_widget_set_sensitive(edit_dialog("apply_bt"),FALSE);

  buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW (view)); g_assert(buffer);
  gtk_text_buffer_get_bounds(buffer, &start, &end);
  gtk_text_buffer_delete(buffer, &start, &end);

  gtk_text_view_set_wrap_mode(GTK_TEXT_VIEW(view), GTK_WRAP_WORD);
  gtk_text_view_set_left_margin(GTK_TEXT_VIEW(view), 5);
  ttfdesc = pango_font_description_copy(GTK_WIDGET(view)->style->font_desc);
  pango_font_description_set_family (ttfdesc, "monospace");
  gtk_widget_modify_font(view, ttfdesc);

  if (!(f = fopen(glob.options_file, "r"))) {
    quick_message("uh ? cannot find %s", glob.options_file); return -1;
  } else {
    char rd[20];
    int cnt, lcnt = 1;
    int got_warning = 0;
    do {
      cnt = fread(rd, 1, sizeof rd - 1, f); 
      if (cnt > 0) {
        char *utf8, *p;
        gsize utf8_len;
        rd[cnt] = 0;
        for (p = rd; *p; ++p) if (*p == '\n') lcnt++;
        utf8 = g_locale_to_utf8(rd, -1, NULL, &utf8_len, NULL);
        if (!utf8 || utf8_len == 0) {
          if (!got_warning) {
            quick_message("gtk could not convert your option file to utf8 -- "
                          "check your locales, check for fucking caracters in your file (around line %d)..\n"
                          "I am now going to patiently strip all non ascii caracters. You have been warned.", lcnt);
            got_warning = 1;
          }
          for (p = rd; *p; ++p) { if (*p < 0) *p = ' '; }
          utf8 = g_locale_to_utf8(rd, -1, NULL, &utf8_len, NULL); g_assert(utf8); g_assert(utf8_len);
        }
        //gtk_text_buffer_get_bounds(buffer, &start, &end);
        gtk_text_buffer_insert_at_cursor(buffer, utf8, utf8_len);
        g_free(utf8);
      }
    } while (cnt == sizeof rd - 1);
  }
  gtk_text_buffer_insert_at_cursor(buffer, "\n\n# append your new options here (or edit the values above)\n\n", -1);
  colorize_edit_dialog();

  gtk_text_buffer_get_bounds(buffer, &start, &end);
  GtkTextMark *end_mark =  gtk_text_buffer_create_mark(buffer, "end", &end, 0); g_assert(end_mark);
  gtk_text_view_scroll_mark_onscreen(GTK_TEXT_VIEW(view), end_mark);
  return 0;
}

int validate_edit_dialog() {
  printf("saving prefs.. syncing..\n");
  return 0;
}

int run_edit_dialog() {
  int rep = GTK_RESPONSE_ACCEPT; 
  if (prepare_edit_dialog() == 0) {
    do {
      printf("run !\n");
      rep = gtk_dialog_run(GTK_DIALOG(edit_dialog(NULL)));
      if (rep != GTK_RESPONSE_OK) {
        return rep;
      }
      if (validate_edit_dialog() == 0) {
        return GTK_RESPONSE_OK;
        break;
      }
    } while (1);
  }
  printf("resp : %d\n", rep);
  return rep;
}

int run_bronson_wizard() {
  int rep = gtk_dialog_run(GTK_DIALOG(bronson_wizard(NULL)));
  printf("rep = %d\n");
  return 0;
}

int
main (int argc, char *argv[])
{
  enum { ADD_NEW_BOARD, ADD_NEW_RSS, CONFIG_PINNI, ABORT_WMCCC, EDIT_CONFIG, BRONSON_WIZARD } action;
#ifdef ENABLE_NLS_POUR_WMCCC
  bindtextdomain (GETTEXT_PACKAGE, PACKAGE_LOCALE_DIR);
  bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
  textdomain (GETTEXT_PACKAGE);
#endif

  glob.current_site = 0;
  glob.main_win = NULL;
  glob.nb_selected_sites = 0;
  //  gtk_set_locale ();

  umask(077);
  gtk_set_locale ();
  gtk_init (&argc, &argv);

  add_pixmap_directory (WMCCDATADIR);

  glob.modif_widget_color.red = 32000;
  glob.modif_widget_color.green = 000;
  glob.modif_widget_color.blue = 000;
  gdk_colormap_alloc_color(gdk_colormap_get_system(), &glob.modif_widget_color, FALSE, TRUE);


  if (strcmp(argv[1], "-wmccpid")==0) {
    g_print("wmc³ launched from wmc²\n"); g_assert(argc == 5);
    glob.wmcc_pid = atoi(argv[2]);
    glob.options_file = strdup(argv[3]);
    glob.tmp_options_file = strdup(argv[4]);
    argc-=4; argv+=4;
  } else {
    glob.wmcc_pid = 0;    
    if (argc < 2 || strcmp(argv[1],"-o")) {
      g_print("missing -o option_file");
      return -1;
    } 
    glob.options_file = strdup(argv[2]);
    glob.tmp_options_file = NULL;
    argc -= 2; argv += 2;
  }

  Prefs = NULL;
  read_prefs();

  action = ABORT_WMCCC;
  if (strcasecmp(argv[1], "-new-board")==0) {
    action = ADD_NEW_BOARD; argc--; argv++;
  } else if (strcasecmp(argv[1], "-new-rss")==0) {
    action = ADD_NEW_RSS; argc--; argv++;
  } else if (strcasecmp(argv[1], "-config-pinni")==0) {
    action = CONFIG_PINNI; argc--; argv++;
  } else if (strcasecmp(argv[1], "-edit")==0) {
    action = EDIT_CONFIG; argc--; argv++;
  } else if (strcasecmp(argv[1], "-wizard")==0 || strcasecmp(argv[1], "-charles-bronson")==0) {
    action = BRONSON_WIZARD; argc--; argv++;
  }


  while (argc > 1 && strcasecmp(argv[1], "-site")==0) {
    assert(argc > 2);
    char *sname = argv[2];
    SitePrefs *sp =  wmcc_prefs_find_site(Prefs, sname);
    if (sp) {
      glob.selected_sites[glob.nb_selected_sites++] = sp;
    }
    argc -=2; argv += 2;
  }


  /* petite bidouille pour les alias de sites et le nom de site */
  {
    int snum;
    for (snum = 0; snum < Prefs->nb_sites; snum++) {
      SitePrefs *sp = Prefs->site[snum];
      int i;
      sp->all_names = g_renew(char *, sp->all_names, MAX(4, sp->nb_names));
      for (i = sp->nb_names; i < 4; i++) sp->all_names[i] = NULL;
      sp->site_name = NULL;
    }
  }

  switch (action) 
  {
    case ABORT_WMCCC:
    case ADD_NEW_RSS:
      break;
    case ADD_NEW_BOARD: {
      run_new_board_dialog();
    } break;
    case CONFIG_PINNI: {
      if (prepare_pinnipede_dialog() == 0) {
        do {
          int rep = gtk_dialog_run(GTK_DIALOG(pinnipede_dialog(NULL)));
          if (rep != GTK_RESPONSE_OK) break;        
        } while (validate_pinnipede_dialog());
      }
    } break;
    case EDIT_CONFIG: run_edit_dialog(); break;
  case BRONSON_WIZARD: run_bronson_wizard(); break;
    default: g_assert(0);
  }
  //gtk_main();
  return 0;
}

